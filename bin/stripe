#!/usr/bin/env node

const Promise = require('bluebird');
const co = Promise.coroutine;
const client = require('@segment/source')();
const conf = require('@segment/config');
const defaults = require('defaults');
const extend = require('extend');
const pkg = require('../package.json');
const createLogger = require('@segment/kit/lib/logger');
const parallel = require('co-parallel');
const program = require('commander');
const request = require('co-request');
const resources = require('../lib/resources');
const wait = require('co-wait');

// command line
program
  .option('--secret <secret>', 'set the stripe secret key')
  .parse(process.argv);

// logger
const log = createLogger({
  name: pkg.name,
  version: pkg.version
});

const concurrencyLimit = 10
require('https').globalAgent.maxSockets = concurrencyLimit;

// pull from stripe
function pull() {
  const tasks = Object.keys(resources)
    .map(key => resources[key])
    .filter(resource => resource._url)
    .map(resource => fetch(resource))

  return parallel(tasks, concurrencyLimit);
}

// pull a specific resource from stripe
const fetch = co(function* (resource) {
  var options = { limit: 100 };
  log.info({ collection: resource._collection }, 'starting collection query ..');
  do {
    var response = yield executeWithRetry(resource._url, options);
    var body = response.body;

    body.data.forEach(co(function* (obj) {
      // subpaginate the object's lists
      resource._subpages.forEach(co(function* (subpage) {
        obj[subpage] = yield depaginate(obj[subpage]);
      }));

      yield resource._consume(client, obj);
    }));

    if (body.data.length > 0)
      options.starting_after = body.data[body.data.length - 1].id;
  } while (body.has_more);
  log.info({ collection: resource._collection }, 'collection finished');
});

// depaginate the entire array by following the links
const depaginate = co(function* (body) {
  var data = body.data;
  var options = { limit: 100 };
  while (body.has_more) {
    options.starting_after = body.data[body.data.length - 1].id;
    var url = 'https://api.stripe.com' + body.url;
    var response = yield executeWithRetry(url, options);
    body = response.body;
    data = data.concat(body.data);
  }
  return data;
});

// execute the request with a few retries
function executeWithRetry(url, options) {
  return retry(execute.bind(null, url, options), {
    retries: 5, // retry 5 times
    interval: 5000, // wait interval first before retrying
    factor: 2 // multiple interval by factor every response to get backoff
  });
}

// retry a function with properties
// based off co-retry but with logging
const retry = co(function* (fn, options) {
  var attempts = options.retries + 1;
  var interval = options.interval;
  while (true) {
    try {
      return yield fn();
    } catch (e) {
      log.error(e);
      attempts--;
      if (!attempts || (e.response && e.response.statusCode === 401)) throw e;
      yield wait(interval);
      interval = interval * options.factor;
    }
  }
});

// execute the request with error handling
const execute = co(function* (url, options) {
  var response = yield request(req(url, options));
  if (response.statusCode !== 200) {
    const err = new Error('Bad Stripe response');
    err.response = response;
    if (response.statusCode === 401) {
      err.message = 'Invalid credentials';
      err.showToUser = true;
    }
    throw err;
  }
  return response;
});

// create a new stripe request
function req(url, options) {
  return {
    url: url,
    method: 'GET',
    auth: { user: program.secret, pass: '' },
    qs: defaults(options || {}, { limit: 100 }),
    json: true
  };
}

// start the program
const start = co(function* () {
  try {
    return pull();
  } catch (e) {
    log.fatal(e, 'application crashed');
    throw e;
  }
});

function onSuccess() {
  log.info('finished running data source successfully');
}

function onError(err) {
  log.fatal(err, 'an error has caused this application to crash');
  if (err.showToUser) {
    return client.report().error(err.message).then(() =>
      process.exit(0)
    );
  }
  process.exit(1);
}

// global error logger
process.on('uncaughtException', function (err) {
  log.fatal(err, 'uncaught exception');
});

// start the program
start().then(onSuccess).catch(onError);
